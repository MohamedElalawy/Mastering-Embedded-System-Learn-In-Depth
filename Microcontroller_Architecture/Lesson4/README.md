
**Introduction to Interrupts**

*   An interrupt is a signal (an "interrupt request" or IRQ) generated by an event external to the CPU [1-6].
*   This signal causes the CPU to stop its current task and jump to a separate piece of code designed to handle the event [1-6].
*   Think of an interrupt in social life like someone requesting your attention, causing you to stop what you're doing and attend to them [1].
*   When the interrupt handling code finishes, the CPU returns to the task it was doing before the interrupt occurred, and the interrupted task continues as if it hadn't been stopped [6, 7].
*   Interrupts are essentially hardware-invoked function calls [7].
*   Interrupts and polling are two different ways to handle input from I/O devices [8]. With interrupts, the device notifies the CPU when it needs attention, while with polling, the CPU constantly checks the device status [9, 10]. Interrupts are more efficient in CPU usage compared to polling, where the CPU is tied down constantly checking for updates [10-14].

**Interrupt Service Routines (ISR)**

*   The code that handles an interrupt is called an Interrupt Service Routine (ISR) or interrupt handler [6, 15-17].
*   For every interrupt, there must be a corresponding ISR [15].
*   When an interrupt happens, the microcontroller runs the associated ISR [15].
*   Each ISR has a fixed location in memory where its address is stored [15].

**Interrupt Vector Table (IVT)**

*   The table of memory locations that hold the addresses of ISRs is called the Interrupt Vector Table (IVT) [15].
*   Interrupt vectors are memory addresses of interrupt handlers [18].
*   The location of each interrupt vector in program memory is typically provided by the microcontroller vendor in its datasheet and cannot be changed by the programmer, although the data at the vector location can be changed [18, 19].
*   Program memory should be reserved for storing pointers to interrupt handlers when utilizing interrupts [18].
*   The IVT should contain the initial value of the Stack Pointer, the starting address of the reset handler, and the starting addresses of all other exceptions and interrupts [20].

**Interrupt Handling Process**

*   An interrupt involves a combination of software and hardware [7].
*   When an interrupt occurs, the processor finishes the current instruction [21].
*   The processor then tests for an interrupt, acknowledges the device that generated it, and saves the necessary information (like the program status word and the address of the next instruction) to the system control stack to be able to resume the interrupted program [21]. This saving process is referred to as switching context [21, 22].
*   The processor loads the program counter with the entry location of the interrupt-handling program from the IVT [23, 24].
*   The CPU then executes the ISR [25, 26].
*   After the interrupt processing is complete, the saved register values (context) are restored from the stack [22].
*   The program counter and PSW values are restored from the stack, allowing the processor to resume the previously interrupted program [22]. This restoration is called context restore [22].

**Interrupt Hardware Signals (inside SoC)**

*   The Interrupt Controller (IC) is responsible for managing interrupts for the CPU [27, 28].
*   The IC tells the CPU when a specific external device wants to interrupt [27].
*   It also informs the CPU which device needs service [27].
*   The IC translates the Interrupt Request (IRQ) to a vector, raises the interrupt to the CPU, and waits for an acknowledgment from the CPU [27].
*   Interrupts can have varying priorities, and the IC is also responsible for prioritizing multiple requests [27].
*   Interrupts can be masked (disabled) at either the IC or the CPU [27].
*   The Interrupt Controller receives interrupt signals from internal modules like UART, CAN, and I2C, as well as from external interrupts [29].

**Functional Attributes for ISR: weak and alias**

*   ISRs are often declared as `weak` in the system startup code [17].
*   The `weak` attribute means that a non-weak subroutine with the same name defined elsewhere can override it [17, 30]. This is useful for library functions that can be customized in user code [30, 31].
*   The `alias("target")` attribute causes a declaration to be emitted as an alias for another symbol [30].

**Servicing Interrupts**

*   There are two general ways microcontrollers service interrupts: Non-Vectored Priority System and Vectored Arbitration System [32].
*   **Non-Vectored Priority System:** When an interrupt occurs, the PC branches to a specific address. Interrupts must be checked sequentially at this address to identify the source [33]. This method can be slow, leading to delays between the interrupt occurrence and servicing, but the programmer can set interrupt priority [33]. It's feasible for microcontrollers with fewer than five interrupts [33].
*   **Vectored Arbitration System:** Some machines reserve a portion of program memory for interrupt vectors [19]. Each interrupt vector contains the address of its corresponding service routine [19]. The compiler places the appropriate address for the handler in the interrupt vector [19]. You usually need to inform the compiler of the interrupt vector's location in program memory [19].

**Interrupt Types**

*   **Asynchronous / Hardware Interrupts:** These are from external sources like I/O devices and are not related to the instruction being executed [34]. They are triggered by electronic alerting signals from external devices or internal modules [35]. I/O devices have Interrupt Request Lines (IRQs) that are mapped to interrupt vectors by a Programmable Interrupt Controller (PIC) [35, 36].
*   **Synchronous (also called exceptions):** These are processor-detected or programmed exceptions [34].
    *   **Processor-detected exceptions:**
        *   **Faults:** Correctable errors, and the offending instruction is retried. Examples include writing to a read-only memory segment or reading from an unavailable memory segment [34, 37]. Detected before incrementing the PC [37].
        *   **Traps:** Often used for debugging, and the instruction is not retried [34]. A CPU might be programmed to switch control to a debugger after executing an instruction [38]. Activated after incrementing the PC [38].
        *   **Aborts:** Indicate a major error like hardware failure [34].
    *   **Programmed exceptions:** Requests for kernel intervention, also known as software interrupts or syscalls [34].

**Software Interrupts**

*   Caused by an exceptional condition or a special instruction [39].
*   An example is a divide-by-zero exception [39].
*   Software interrupt instructions are similar to subroutine calls [39].

**Interrupt Latency**

*   Interrupt latency refers to the time between an external interrupt arriving at the processor and the start of interrupt processing [40, 41].
*   Minimizing interrupt latency is crucial for kernel real-time performance [41].

**Interrupt Overload**

*   Interrupt overload occurs when external interrupts are signaled so frequently that other activities on the processor are starved [10, 42].

**Key Concepts and Definitions** [43]

*   **Interrupt:** Hardware-supported asynchronous transfer of control to an interrupt vector.
*   **Interrupt Vector:** A dedicated memory location that specifies the address the execution jumps to.
*   **Interrupt Handler:** Code reachable from an interrupt vector (same as ISR).
*   **Interrupt Controller:** A peripheral device that manages interrupts for the processor.
*   **Pending:** The condition for an interrupt has been met and noticed, but the handler has not started executing.
*   **Interrupt Latency:** The time from when an interrupt's firing condition is met to the start of the interrupt handler's execution.
*   **Nested Interrupt:** Occurs when one interrupt handler is preempted by another.

This covers the key concepts related to interrupts as presented in the provided sources.
---

**NVIC** (Nested Vectored Interrupt Controller) and the **GIC** (Generic Interrupt Controller) are **not the same**, though they serve similar purposes: managing interrupts in ARM-based systems. Here's a breakdown of their differences:

---

### ðŸ”¹ **NVIC â€“ Nested Vectored Interrupt Controller**

* **Used in:** ARM **Cortex-M** series (microcontrollers).
* **Purpose:** Manages interrupt priorities, enables/disables interrupts, supports nested interrupts.
* **Integrated:** Inside the Cortex-M core.
* **Simple and lightweight**, suitable for **bare-metal or RTOS-based** systems.
* **Registers:** Direct memory-mapped access to enable, disable, set priority, etc.

---

### ðŸ”¹ **GIC â€“ Generic Interrupt Controller**

* **Used in:** ARM **Cortex-A** series (application processors, like in Linux-capable SoCs).
* **Purpose:** Handles interrupts in more complex, multi-core systems (e.g., smartphones, embedded Linux).
* **Separate hardware block** from the processor core.
* Supports **distribution** of interrupts among multiple cores.
* Supports **interrupt virtualization** for hypervisors.
* **More complex** than NVIC, with components like:

  * **Distributor**
  * **CPU Interface**
  * **Redistributors** (in GICv3 and later)

---

### ðŸ”¸ Summary Table

| Feature           | NVIC (Cortex-M)     | GIC (Cortex-A)            |
| ----------------- | ------------------- | ------------------------- |
| Target core       | Cortex-M (MCU)      | Cortex-A (Application)    |
| Complexity        | Simple              | Complex (multi-core, OS)  |
| Use case          | Bare-metal / RTOS   | Linux / Hypervisor        |
| Integration       | Inside the CPU core | External or semi-external |
| Interrupt nesting | Yes                 | Yes                       |
| Virtualization    | No                  | Yes                       |

---

