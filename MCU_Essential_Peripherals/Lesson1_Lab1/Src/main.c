/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


//=============================
// Macros Configuration
//=============================
#define SET_BIT(REG, BIT)        ((REG) |=  (1 << (BIT)))
#define CLEAR_BIT(REG, BIT)      ((REG) &= ~(1 << (BIT)))
#define TOGGLE_BIT(REG, BIT)     ((REG) ^=  (1 << (BIT)))
#define READ_BIT(REG, BIT)       (((REG) >> (BIT)) & 0x1)

//=============================
// Base Addresses
//=============================
#define RCC_BASE                0x40021000UL
#define GPIOA_BASE              0x40010800UL
#define GPIOB_BASE              0x40010C00UL

//=============================
// RCC Registers
//=============================
#define RCC_APB2ENR             *((volatile uint32_t *)(RCC_BASE + 0x18))

//=============================
// GPIO Registers
//=============================
#define GPIOA_CRL               *((volatile uint32_t *)(GPIOA_BASE + 0x00))
#define GPIOA_CRH               *((volatile uint32_t *)(GPIOA_BASE + 0x04))
#define GPIOA_IDR               *((volatile uint32_t *)(GPIOA_BASE + 0x08))
#define GPIOA_ODR               *((volatile uint32_t *)(GPIOA_BASE + 0x0C))

#define GPIOB_CRL               *((volatile uint32_t *)(GPIOB_BASE + 0x00))
#define GPIOB_CRH               *((volatile uint32_t *)(GPIOB_BASE + 0x04))
#define GPIOB_IDR               *((volatile uint32_t *)(GPIOB_BASE + 0x08))
#define GPIOB_ODR               *((volatile uint32_t *)(GPIOB_BASE + 0x0C))

//=============================
// Function Prototypes
//=============================
void MCAL_GPIOX_Init(void);
void Delay_ms(uint32_t Delay);

//=============================
// Function Implementations
//=============================

void MCAL_GPIOX_Init(void)
{
    // Enable GPIOA and GPIOB clocks
    SET_BIT(RCC_APB2ENR, 2); // IOPAEN
    SET_BIT(RCC_APB2ENR, 3); // IOPBEN

    // Reset configuration registers
    GPIOA_CRL = 0x00000000;
    GPIOA_CRH = 0x00000000;
    GPIOB_CRL = 0x00000000;
    GPIOB_CRH = 0x00000000;

    // Configure PA1 and PA13 as input floating (01)
    GPIOA_CRL |= (0b01 << (1 * 4));
    GPIOA_CRH |= (0b01 << ((13 - 8) * 4));

    // Configure PB1 and PB13 as output push-pull (01: mode = 10MHz, 00: CNF = push-pull)
    GPIOB_CRL |= (0b01 << (1 * 4));    // MODE1 = 01
    GPIOB_CRL &= ~(0b11 << (1 * 4 + 2)); // CNF1 = 00

    GPIOB_CRH |= (0b01 << ((13 - 8) * 4));   // MODE13 = 01
    GPIOB_CRH &= ~(0b11 << ((13 - 8) * 4 + 2)); // CNF13 = 00
}

void Delay_ms(uint32_t Delay)
{
    volatile uint32_t i;
    for (i = 0; i < Delay; i++);
}


int main(void)
{
    MCAL_GPIOX_Init();

    while (1)
    {
        // PA1 connected to external pull-up
        if (READ_BIT(GPIOA_IDR, 1) == 0)
        {
            TOGGLE_BIT(GPIOB_ODR, 1);
            while (READ_BIT(GPIOA_IDR, 1) == 0); // Wait for button release
        }

        // PA13 connected to external pull-down
        if (READ_BIT(GPIOA_IDR, 13) == 1)
        {
            TOGGLE_BIT(GPIOB_ODR, 13);
        }

        Delay_ms(10000);
    }

    return 0;
}
